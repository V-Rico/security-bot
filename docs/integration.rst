.. _integration:

Integration
===========

On this page, you will find an adequate checklist and step-by-step
instructions to ensure the successful integration of your service with the
Security Bot (SecBot) solution.

Configuration Files
-------------------

The service (``/.env.dev``) and workflow (``/app/config.yml``)
:doc:`configuration files </configuration>` are updated to meet your
environment's peculiarities and issue processing needs.

If you have made additional alterations, rebuild SecBot and start it again.

.. code-block:: console
    
    $ docker-compose stop
    $ docker-compose up --build
    $ docker-compose up -d

.. _authorization:

Authorization
-------------

All external units that SecBot communicates with via APIs require
authorization. Therefore, the user that performs the communication should have
the respective tokens.

.. _gitlab-auth:

**For GitLab**

1. Sign in to your account
2. Click the profile icon in the upper-right corner and then click **Edit profile**
3. Click **Access Token** on the **User Settings** left-side menu
4. On the open page, enter your *Token name*, check the *Expiration date*, select ``read_api`` under **Select scopes**, and then click the :guilabel:`Create personal access token` button below

.. image:: /images/gitlab-access-token.png
   :alt: GitLab access token

5. Copy *Your new personal access token* generated by GitLab and ensure you securely store it, as it will not be displayed again.

**For DefectDojo**

1. Log in under the admin's (superuser's) account
2. Point to the *Users* left-side menu and then click **Users**
3. On the open page, click the *Settings* toolbar button and then click **New User**
4. On the **Add User** page, enter the following parameters of the user that will communicate with the API:

    a. *Username* and *Password* under **Default Information**
    b. ``Maintainer`` as the *Global role* under **Global Role**

5. Click the :guilabel:`Submit` button and make sure that the *User has been added successfully*

.. image:: /images/defectdojo-user.png
   :alt: DefectDojo SecBot user

6. Log in under the added user's account
7. Click the profile icon in the upper-right corner and then click **API v2 Key**
8. On the open page, copy *Your current API key* generated by DefectDojo and ensure you securely store it.

**For Slack**

1. Go to ``https://api.slack.com`` to sign in to your workspace
2. Create an app; to do it,

    a. Click the :guilabel:`Your Apps` menu
    b. Click the :guilabel:`Create New App` button on the open page
    c. Choose **From scratch** in the open **Create an app** dialog box
    d. Enter your *App Name* and *Pick the workspace* where you want to install this app in the following **Name app & choose workspace** dialog box
    e. Click the :guilabel:`Create App` button

3. Click the **OAuth & Permissions** left-side menu under **Features** on the app's dashboard
4. Scroll down to the **Scopes** section and click the :guilabel:`Add an Oath Scope` button under **Bot Token Scopes** to select ``chat:write``
5. Scroll up to the **OAuth Tokens for Your Workspace** section and click the :guilabel:`Install to Workspace` button

    * Allow the app to access the workspace if requested

6. Copy your *Bot User OAuth Token* generated by Slack and ensure you securely store it.

.. image:: /images/slack-dashboard.png
   :alt: Slack Dashboard

.. _input_entity_sources:

Input Entity Sources
--------------------

The SecBot instance responsible for receiving requests to process data
triggers as soon as a relevant input event comes up. Thus, you are expected to
specify these triggers for supported development and distribution platforms
(Inputs).

**For GitLab**

1. Sign in under an admin's account
2. Click the **System Hooks** left-side menu to add new or update existing system hooks
3. On the open page, enter in the **URL** text box the reference to the method used to receive information on changes made to the repository in your environment

    * *[host]/v1/gitlab/webhook*

4. Enter the :ref:`authentication token <gitlab-auth>` for your requests in the **Secret token** text box
5. Select the types of input events you want to be processed under **Trigger**, for example, any supported :term:`Input entity` type like ``Push events``, ``Tag push events``, and ``Merge request events``

.. image:: /images/gitlab-system-hooks.png
   :alt: GitLab system hooks

6. Click the :guilabel:`Add system hook` or :guilabel:`Save changes` button below.

API
---

Communication with SecBot's API involves providing input entities or receiving
check results via the dedicated endpoints (instances). Follow

* ``[host]:5000/docs`` and
* ``[host]:5001/docs``, respectively.

In the first case, mind the

1. :term:`Input entity` (input event) type you will specify as the ``x-gitlab-event`` header parameter and the
2. respective payload in the request body.

A specific result is retrieved by *security_check_id*, which is formed by
concatenating the following pieces:

1. input platform (e.g. git) prefix,
2. sha256 of the project path, and
3. complete commit hash.

.. code-block:: text

    # security_check_id example

    GIT_LOCAL_d42052411d2729e637980c355cf6a8ea8e41b8688b98c34a125b71b7f2c7f76e

Pipeline
--------

Integration of SecBot into your pipeline as an additional stage is an option
we suggest that you consider. Depending on the status received upon checks,
this stage might

* get passed ('success'),
* stay pending ('not_started' or 'in_progress'), or
* fail ('error' or 'fail').

The following excerpt demonstrates a comprehensive example of how this
integration can be implemented.

.. code-block:: yaml

    # Excerpt from .../pipeline.yml

    ...
    .gate-sec-scripts:
      before_script:
        - apk add curl jq
        - SECURITY_CHECK_URL="https://[gateway_url]/v1/security/gitlab/check"
        - SECURITY_CHECK_UID="GIT_LOCAL_$(echo -n "${CI_SERVER_HOST}:${CI_PROJECT_PATH}_${CI_COMMIT_SHA}" | sha256sum | head -c64)"
      script:
        - SECURITY_CHECK_STATUS=$(curl -k -s -w " %{http_code}" $SECURITY_CHECK_URL/${SECURITY_CHECK_UID})
        - SECURITY_CHECK_STATUS_JSON=$(echo $SECURITY_CHECK_STATUS | awk '{print $1}')
        - SECURITY_CHECK_STATUS_CODE=$(echo $SECURITY_CHECK_STATUS | awk '{print $2}')
        - |
          if [ "$SECURITY_CHECK_STATUS_CODE" != "200" ]; then
            echo " Something went wrong, status: $SECURITY_CHECK_STATUS"
            exit 1
          fi
        - SECURITY_CHECK_STATUS_JSON_STATUS_DESCRIPTION=''
        - SECURITY_CHECK_STATUS_JSON_STATUS=$(echo $SECURITY_CHECK_STATUS_JSON | jq -r '.status')
        - |
          if [ $SECURITY_CHECK_STATUS_JSON_STATUS = "fail" ]; then
            SECURITY_CHECK_STATUS_JSON_STATUS_DESCRIPTION="--> Vulnerabilities found"
          elif [ $SECURITY_CHECK_STATUS_JSON_STATUS = "success" ]; then
            SECURITY_CHECK_STATUS_JSON_STATUS_DESCRIPTION="--> No vulnerabilities found"
          fi
        - echo " Response Code --> $SECURITY_CHECK_STATUS_CODE"
        - echo " Status --> $SECURITY_CHECK_STATUS_JSON_STATUS $SECURITY_CHECK_STATUS_JSON_STATUS_DESCRIPTION"
    ...